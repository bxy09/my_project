#!/usr/bin/perl -w
use warnings;
use strict;
require MongoDB;
require MongoDB::OID;
use threads;
use threads::shared;
use Thread::Queue;
use Test::Parser::Sar;
use Data::Dumper;
use POSIX;
use JSON;
#########################################
eval "use ${_}" # no Any::Moose::load_class becase the namespaces already have symbols from the xs bootstrap
  for qw/MongoDB::Database MongoDB::Cursor MongoDB::OID MongoDB::Timestamp/;
my @nodes;
share(@nodes);
read_nodelist();

my @signals = ();
get_signals();
sub get_signals{
	my @signal_clusters = (
						{db=>'Job_signal',num=>8},
						{db=>'Sar_signal',num=>181},
						{db=>'lim',num=>7},
						{db=>'pim',num=>1},
						{db=>'res',num=>15},
						{db=>'sbatchd',num=>20},
						{db=>'messages',num=>2}
						);
	foreach my $signal_cluster(@signal_clusters){
		my $num = $signal_cluster->{num};
		my $db_handle = MongoDB::Connection->new()->get_database($signal_cluster->{db});
		#ensure_index
		foreach my $node(@nodes) {
			$db_handle->get_collection($node)->ensure_index({'tempID'=>1,'logTime'=>1});
		}
		foreach (0..($num-1)) {
			push @signals,{tempID=>$_,db=>$signal_cluster->{db}};
		}
	}
}
#get signal_list
#foreach signal*signal calc num and cov_num
my $cov_mat= [];
my $count = [];
foreach my $i(0..$#signals) {
	push @$count,0;
	my @row:shared;
	foreach my $j(0..$#signals) {
		push @row,0;
	}
	push @$cov_mat,\@row;
}
my $all_records;
my $j_queue = Thread::Queue->new();
foreach my $node(@nodes) {
	print "start read $node\n";
	foreach my $i(0..$#signals) {
		my $i_records;my $num;
		$i_records = get_all_records($i,$node);
		$count->[$i] += scalar @$i_records;
		$all_records->{$i} = $i_records;
	}
	print "after read $node\n";
	foreach my $i(0..$#signals) {
		foreach my $j (0..$#signals) {
			$j_queue->enqueue("$i $j");
		}
	}
	my $threads_num = 20;
	my @threads_pool;
	foreach (1..$threads_num) {
		push @threads_pool ,threads->create(\&count_cov,$_);
	}
	while($j_queue->pending!=0) {
		sleep 1;
	}
		foreach (@threads_pool) {
		$_->join;
	}
}

#print
my $big_ratio_couple = [];
foreach my $i(0..$#signals){
	printf "sig:%10s count:%10d ","$signals[$i]->{db}:$signals[$i]->{tempID}",$count->[$i];
	foreach my $j(0..$#signals){
		if(print_cov_cell($i,$j)>0.8) {
			push @$big_ratio_couple,[$i,$j];
		}
	}
	print "\n";
}
print "big::::::\n";
foreach my $couple (@$big_ratio_couple) {
	my ($i,$j) = @$couple;
	printf "sig:%10s count:%10d ","$signals[$i]->{db}:$signals[$i]->{tempID}",$count->[$i];
	printf "sig:%10s count:%10d ","$signals[$j]->{db}:$signals[$j]->{tempID}",$count->[$j];
	print_cov_cell($i,$j);
	print "\n";
}
#####################################################
sub get_all_records {
	my $i = shift @_;
	my $node = shift @_;
	my $i_handle = MongoDB::Connection->new()->get_database($signals[$i]->{db});
	my $ret_hash;
	my $records_sum = 0;
	my $i_cursor= $i_handle->get_collection($node)->find({'tempID'=>$signals[$i]->{tempID}},{'logTime'=>1})->sort({'logTime'=>1});
	my @node_records_vec;
	my $time = 0;
	while(my $i_record = $i_cursor->next()) {
		if($i_record->{logTime}-$time<10*60) {
			next;
		}
		$time = $i_record->{logTime};
		push @node_records_vec,$time;
		$records_sum++;
	}
	return \@node_records_vec;
}
sub bsearch_num_pos {
    my ( $target, $aref ) = @_;
    my ( $low, $high ) = ( 0, scalar @{$aref} );
    while ( $low < $high ) {
        my $cur = int( ( $low + $high ) / 2 );
        if ( $target > $aref->[$cur] ) {
            $low = $cur + 1;    # too small, try higher
        }
        else {
            $high = $cur;       # not too small, try lower
        }
    }
    return $low;
}
sub count_cov {
	my ($thread_no) = @_;
	print "thread $thread_no init!!\n";
	my $pair;
	while(defined ($pair = $j_queue->dequeue_nb())) {
		my ($i,$j) = split /\s+/,$pair;
		if($j == $i) {next;}
		#print "thread $thread_no get j:$j i:$i $signals[$i]->{db}\n";
		my $ret_val = 0;
		defined $all_records->{$j} and scalar @{$all_records->{$j}} > 0 or next;
		defined $all_records->{$i} and scalar @{$all_records->{$i}} > 0 or next;
		my $j_list = $all_records->{$j};
		foreach my $time(@{$all_records->{$i}}) {
			#在ilog的上下三十分钟内是否存在jlog
			my $index = &bsearch_num_pos($time-60*60,$j_list);
			$index < scalar @$j_list or next;
			$j_list->[$index] <= $time+60*60 or next;
			$ret_val++;
		}
		$cov_mat->[$i][$j] += $ret_val;
	}
	print "thread $thread_no exit!!\n";
}
sub print_cov_cell{
	my ($i,$j) = @_;
	my $ratio = 0;
	if($count->[$i]==0) {
		$ratio = 0;
	}else {
		$ratio = $cov_mat->[$i][$j]/$count->[$i];
	}
	printf "%10d/%1.4f ",$cov_mat->[$i][$j],$ratio;
	return $ratio;
}
sub read_nodelist{
	my $node_list_path = shift @ARGV;
	open NODE,"<$node_list_path" or die "can't open nodelist:$node_list_path";
	while(<NODE>) {
		s/\r\n//;
		push @nodes,$_;
	}
}
