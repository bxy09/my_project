#!/usr/bin/perl -w
use warnings;
use strict;
require MongoDB;
require MongoDB::OID;
use threads;
use threads::shared;
use Test::Parser::Sar;
use Data::Dumper;
use POSIX;
use JSON;
#########################################
my @nodes;
    eval "use ${_}" # no Any::Moose::load_class becase the namespaces already have symbols from the xs bootstrap
        for qw/MongoDB::Database MongoDB::Cursor MongoDB::OID MongoDB::Timestamp/;
share(@nodes);
read_nodelist();

my @signals = ();
get_signals();
sub get_signals{
	my @signal_clusters = (
						{db=>'Job_signal',num=>8},
						{db=>'Sar_signal',num=>181},
						{db=>'lim',num=>7},
						{db=>'pim',num=>1},
						{db=>'res',num=>15},
						{db=>'sbatchd',num=>20},
						{db=>'messages',num=>2}
						);
	foreach my $signal_cluster(@signal_clusters){
		my $num = $signal_cluster->{num};
		my $db_handle = MongoDB::Connection->new()->get_database($signal_cluster->{db});
		#ensure_index
		foreach my $node(@nodes) {
			$db_handle->get_collection($node)->ensure_index({'tempID'=>1,'logTime'=>1});
		}
		foreach (0..($num-1)) {
			push @signals,{tempID=>$_,db=>$signal_cluster->{db}};
		}
	}
}
#get signal_list
#foreach signal*signal calc num and cov_num
my $cov_mat= [];
my $count = [];
foreach my $i(0..$#signals) {
	push @$count,0;
	my $cov_row;
	foreach my $j(0..$#signals) {
		push @$cov_row,0;
	}
	push @$cov_mat,$cov_row;
}
my $i_records;
my $i_count;
foreach my $i(0..$#signals) {
	die if($i == 1);
	#get signal num
	($i_count,$i_records) = get_all_records($i);
	my $i_tempID = $signals[$i]->{tempID};
	my %threads_pool = ();
	my $calc_j_num = 0;
	my $threads_cap = 1;
	print "calc $i\n";
	while($calc_j_num != scalar @signals or scalar keys(%threads_pool)!=0) {
		foreach my $key (keys(%threads_pool)) {
			if($threads_pool{$key}->is_joinable()) {
				$cov_mat->[$i][$key] = $threads_pool{$key}->join();
				print "join $key $cov_mat->[$i][$key]";
				delete $threads_pool{$key};
			}
		}
		while(scalar keys(%threads_pool) != $threads_cap and $calc_j_num != scalar @signals) {
			if($calc_j_num == $i){$calc_j_num++;next;};
			print "\t create $calc_j_num\n";
			$threads_pool{$calc_j_num} = threads->create(\&count_cov,$i,$calc_j_num);
			$calc_j_num++;
		}
		sleep 0.01;
	}
}
#print
my $big_ratio_couple = [];
foreach my $i(0..$#signals){
	printf "sig:%10s count:%10d ","$signals[$i]->{db}:$signals[$i]->{tempID}",$count->[$i];
	foreach my $j(0..$#signals){
		if(print_cov_cell($i,$j)>0.8) {
			push @$big_ratio_couple,[$i,$j];
		}
	}
	print "\n";
}
print "big::::::\n";
foreach my $couple (@$big_ratio_couple) {
	my ($i,$j) = @$couple;
	printf "sig:%10s count:%10d ","$signals[$i]->{db}:$signals[$i]->{tempID}",$count->[$i];
	printf "sig:%10s count:%10d ","$signals[$j]->{db}:$signals[$j]->{tempID}",$count->[$j];
	print_cov_cell($i,$j);
	print "\n";
}

sub get_all_records {
	my $i = shift @_;
	my $i_handle = MongoDB::Connection->new()->get_database($signals[$i]->{db});
	my $ret_hash;
	my $records_sum;
	foreach my $node(@nodes) {
		my $i_cursor= $i_handle->get_collection($node)->find({'tempID'=>$signals[$i]->{tempID}},{'logTime'=>1});
		my @node_records_vec:shared;
		while(my $i_record = $i_cursor->next()) {
			my $time = $i_record->{logTime};
			push @node_records_vec,$time;
			$records_sum++;
		}
		$ret_hash->{$node} = \@node_records_vec;
	}
	return ($records_sum,$ret_hash);
}
sub count_cov {
	my ($i,$j) = @_;
	my $ret_val = 0;
	my $db_handle = MongoDB::Connection->new()->get_database($signals[$j]->{db});
	foreach my $node(@nodes){
		my $j_col_handle = $db_handle->get_collection($node);
		my $j_tempID = $signals[$j]->{tempID};
		next if($j_col_handle->count({'tempID'=>$j_tempID})==0);
		if(defined $i_records->{$node}) {
			foreach my $time(@{$i_records->{$node}}) {
				#在ilog的上下三十分钟内是否存在jlog
		#print "$j_tempID,,$time\n";
				if($j_col_handle->count({'tempID'=>$j_tempID,'logTime'=>{'$lte'=>$time+60*60,'$gte'=>$time-60*60}})!=0) {
					$ret_val++;
				}
			}
		}
	}
	return $ret_val;
}
sub print_cov_cell{
	my ($i,$j) = @_;
	my $ratio = 0;
	if($count->[$i]==0) {
		$ratio = 0;
	}else {
		$ratio = $cov_mat->[$i][$j]/$count->[$i];
	}
	printf "%10d/%1.4f ",$cov_mat->[$i][$j],$ratio;
	return $ratio;
}
sub read_nodelist{
	my $node_list_path = shift @ARGV;
	open NODE,"<$node_list_path" or die "can't open nodelist:$node_list_path";
	while(<NODE>) {
		s/\r\n//;
		push @nodes,$_;
	}
}
