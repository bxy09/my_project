#!/usr/bin/perl -w
use warnings;
use strict;
require MongoDB;
require MongoDB::OID;
use threads;
use threads::shared;
use List::BinarySearch qw/bsearch_num_pos/;
use Thread::Queue;
use Test::Parser::Sar;
use Data::Dumper;
use POSIX;
use JSON;
#########################################
eval "use ${_}" # no Any::Moose::load_class becase the namespaces already have symbols from the xs bootstrap
  for qw/MongoDB::Database MongoDB::Cursor MongoDB::OID MongoDB::Timestamp/;
my @nodes;
share(@nodes);
read_nodelist();

my @signals = ();
get_signals();
sub get_signals{
	my @signal_clusters = (
						{db=>'Job_signal',num=>8},
						{db=>'Sar_signal',num=>181},
						{db=>'lim',num=>7},
						{db=>'pim',num=>1},
						{db=>'res',num=>15},
						{db=>'sbatchd',num=>20},
						{db=>'messages',num=>2}
						);
	foreach my $signal_cluster(@signal_clusters){
		my $num = $signal_cluster->{num};
		my $db_handle = MongoDB::Connection->new()->get_database($signal_cluster->{db});
		#ensure_index
		foreach my $node(@nodes) {
			$db_handle->get_collection($node)->ensure_index({'tempID'=>1,'logTime'=>1});
		}
		foreach (0..($num-1)) {
			push @signals,{tempID=>$_,db=>$signal_cluster->{db}};
		}
	}
}
#get signal_list
#foreach signal*signal calc num and cov_num
my $cov_mat= [];
my $count = [];
my @return_val:shared;
foreach my $i(0..$#signals) {
	push @return_val,0;
	push @$count,0;
	my $cov_row;
	foreach my $j(0..$#signals) {
		push @$cov_row,0;
	}
	push @$cov_mat,$cov_row;
}
my $all_records;
my $j_queue = Thread::Queue->new();
foreach my $i(0..$#signals) {
	#die if($i == 1);
	#get signal num
	my $i_records;
	($count->[$i],$i_records) = get_all_records($i);
	$all_records->{$i} = $i_records;
}

foreach my $i(0..$#signals) {
	my $i_tempID = $signals[$i]->{tempID};
	$j_queue->enqueue((0..$#signals));
	my $threads_num = 20;
	my @threads_pool;
	foreach (1..$threads_num) {
		push @threads_pool ,threads->create(\&count_cov,$i,$_);
	}
	while($j_queue->pending!=0) {
		sleep 1;
	}
	foreach (@threads_pool) {
		$_->join;
	}
	foreach (0..$#return_val) {
		$cov_mat->[$i][$_] = $return_val[$_];
		$return_val[$_] = 0;
	}
}
#print
my $big_ratio_couple = [];
foreach my $i(0..$#signals){
	printf "sig:%10s count:%10d ","$signals[$i]->{db}:$signals[$i]->{tempID}",$count->[$i];
	foreach my $j(0..$#signals){
		if(print_cov_cell($i,$j)>0.8) {
			push @$big_ratio_couple,[$i,$j];
		}
	}
	print "\n";
}
print "big::::::\n";
foreach my $couple (@$big_ratio_couple) {
	my ($i,$j) = @$couple;
	printf "sig:%10s count:%10d ","$signals[$i]->{db}:$signals[$i]->{tempID}",$count->[$i];
	printf "sig:%10s count:%10d ","$signals[$j]->{db}:$signals[$j]->{tempID}",$count->[$j];
	print_cov_cell($i,$j);
	print "\n";
}
#####################################################
sub get_all_records {
	my $i = shift @_;
	my $i_handle = MongoDB::Connection->new()->get_database($signals[$i]->{db});
	my $ret_hash;
	my $records_sum = 0;
	foreach my $node(@nodes) {
		my $i_cursor= $i_handle->get_collection($node)->find({'tempID'=>$signals[$i]->{tempID}},{'logTime'=>1})->sort({'logTime'=>1});
		my @node_records_vec;
		my $time = 0;
		while(my $i_record = $i_cursor->next()) {
			if($i_record->{logTime}-$time<10*60) {
				next;
			}
			$time = $i_record->{logTime};
			push @node_records_vec,$time;
			$records_sum++;
		}
		$ret_hash->{$node} = \@node_records_vec;
	}
	print $records_sum."\n";
	return ($records_sum,$ret_hash);
}
sub count_cov {
	my ($i,$thread_no) = @_;
	print "thread $thread_no init!! i:$i $signals[$i]->{db}\n";
	my $j;
	while(defined ($j = $j_queue->dequeue_nb())) {
		if($j == $i) {next;}
		print "thread $thread_no get j:$j i:$i $signals[$i]->{db}\n";
		my $ret_val = 0;
		foreach my $node(@nodes){
			defined $all_records->{$j}{$node} and scalar @{$all_records->{$j}{$node}} > 0 or next;
			defined $all_records->{$i}{$node} and scalar @{$all_records->{$i}{$node}} > 0 or next;
			my $j_list = $all_records->{$j}{$node};
			foreach my $time(@{$all_records->{$i}{$node}}) {
				#在ilog的上下三十分钟内是否存在jlog
				my $index = bsearch_num_pos $time-60*60,@$j_list;
				$index < scalar @$j_list or next;
				$j_list->[$index] <= $time+60*60 or next;
				$ret_val++;
			}
		}
		$return_val[$j] = $ret_val;
	}
	print "thread $thread_no exit!!\n";
}
sub print_cov_cell{
	my ($i,$j) = @_;
	my $ratio = 0;
	if($count->[$i]==0) {
		$ratio = 0;
	}else {
		$ratio = $cov_mat->[$i][$j]/$count->[$i];
	}
	printf "%10d/%1.4f ",$cov_mat->[$i][$j],$ratio;
	return $ratio;
}
sub read_nodelist{
	my $node_list_path = shift @ARGV;
	open NODE,"<$node_list_path" or die "can't open nodelist:$node_list_path";
	while(<NODE>) {
		s/\r\n//;
		push @nodes,$_;
	}
}
